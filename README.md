# Discount-Offers
The discount offers challenge from codeeval asks me to find the optimal pairing of products and customers based on a custom scoring rule. The details of the prompt are contained in the instructions.md file or on the web at https://www.codeeval.com/public_sc/48/.

In this challenge, I have created a program that takes a file path argument with each line in that file being a test case, and prints out the maximum combined ss score for each group of products and customers.  The program is run by typing the command "python run.py [data file path]".  There is one external dependency, numpy, which is part of the scipy suite of modules.  Everything else used is within the Python Standard Library.  The classes and functions executing the algorithm live in the file algorithm.py, to isolate them from the execution logic in run.py. I also added test coverage for all functions, contained within the test.py file.  These can be run through the command "python -m unittest test".  There are also two sample ascii data files in the data folder that I included here for testing purposes.  The file data.txt contains the three test cases from the provided prompt in instructions.md (which was copied from the codeeval prompt).

My general approach to solve the problem of finding the maximum ss score was to create a matrix containing the ss scores for each customer product pairing, and then to feed that matrix into a recursive backtracking algorithm that is designed to investigate all possible valid and unique combinations of combined ss scores.  Each call of the recursive backtracking algorithm correlates with one row in the matrix (the row_index parameter), and the calls continue deeper until either there are no more available rows in the matrix or all columns have been used.  As the algorithm goes deeper down the recursive stack, the algorithm remembers which columns were already blocked off by prior choices, ensuring only valid results.  When returning up the recursive stack, those columns are freed up for use in other branches of the recursive cycle.  In this algorithm, a variable is used to remember the max score that has been encountered in each recursive call, and that max score from each level is ultimately returned.

One benefit to this algorithmic approach is simplicity in structure.  Each recursive call only concerns itself with one row, so it is easy to reason about how the algorithm is traversing the matrix.  One downside of this approach is that if there are more rows than columns, then it is not possible to investigate the values at lower rows in one recursive routine.  To deal with this eventuality, there is a separate routine that gets the transpose of the matrix and then runs the same operation.  Since the rows and columns are switched, this transpose operation allows all the eventualities that the first version missed to be covered.  The greater of the "compute_score_by_row" and "compute_score_by_column" routines will give us the desired answer.  I decided on a two routine solution because two simple routines are easier to reason about and maintain than one more complicated routine. The two routine approach has also executed faster as well then my prior one routine approach in local testing.  If you would like to see my single routine solution, please check out the git commit at hash "6c1f999c1eb3c5e9681154ff2a0a6b8ab331826b".
